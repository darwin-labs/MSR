#!/usr/bin/env python3
"""
MSR Log Analyzer Example

This script demonstrates how to parse, analyze, and visualize logs generated by the MSR framework.
It can be used to extract insights from agent execution logs and generate visualizations.

Usage:
    python log_analyzer_example.py --log-file logs/agent_execution.json
"""

import os
import sys
import json
import argparse
import datetime
from typing import Dict, List, Any, Optional
import pandas as pd
import matplotlib.pyplot as plt
from collections import Counter, defaultdict

# Add parent directory to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from src.msr.logger import LogEventType, LogLevel


class LogAnalyzer:
    """Analyzes and visualizes MSR agent logs."""
    
    def __init__(self, log_file: str):
        """
        Initialize the log analyzer.
        
        Args:
            log_file: Path to the log file to analyze
        """
        self.log_file = log_file
        self.logs = self._load_logs()
        self.agents = self._extract_agents()
        self.tasks = self._extract_tasks()
        self.events_by_type = self._group_events_by_type()
        self.step_executions = self._extract_step_executions()
        
    def _load_logs(self) -> List[Dict[str, Any]]:
        """Load and parse the logs from the log file."""
        logs = []
        with open(self.log_file, 'r') as f:
            for line in f:
                try:
                    log = json.loads(line.strip())
                    logs.append(log)
                except json.JSONDecodeError:
                    # Skip invalid JSON lines
                    continue
        return logs
    
    def _extract_agents(self) -> Dict[str, Dict[str, Any]]:
        """Extract agent information from the logs."""
        agents = {}
        for log in self.logs:
            agent_id = log.get('agent_id')
            if agent_id and log.get('event_type') == LogEventType.AGENT_INITIALIZED.name:
                agents[agent_id] = {
                    'task': log.get('context', {}).get('task'),
                    'allowed_tools': log.get('context', {}).get('allowed_tools'),
                    'timestamp': log.get('timestamp'),
                    'log_count': 0
                }
            
            # Count logs per agent
            if agent_id in agents:
                agents[agent_id]['log_count'] = agents[agent_id].get('log_count', 0) + 1
                
        return agents
    
    def _extract_tasks(self) -> Dict[str, Dict[str, Any]]:
        """Extract task information from the logs."""
        tasks = {}
        for log in self.logs:
            task_id = log.get('task_id')
            if task_id and log.get('event_type') == LogEventType.TASK_STARTED.name:
                tasks[task_id] = {
                    'description': log.get('context', {}).get('task'),
                    'agent_id': log.get('agent_id'),
                    'start_time': log.get('timestamp'),
                    'end_time': None,
                    'success': False,
                    'steps_total': 0,
                    'steps_success': 0
                }
            
            # Record task completion
            if task_id in tasks and log.get('event_type') == LogEventType.TASK_COMPLETED.name:
                tasks[task_id].update({
                    'end_time': log.get('timestamp'),
                    'success': log.get('context', {}).get('success', False),
                    'steps_total': log.get('context', {}).get('total_steps', 0),
                    'steps_success': log.get('context', {}).get('successful_steps', 0)
                })
                
        return tasks
    
    def _group_events_by_type(self) -> Dict[str, List[Dict[str, Any]]]:
        """Group log events by their type."""
        events = defaultdict(list)
        for log in self.logs:
            event_type = log.get('event_type')
            if event_type:
                events[event_type].append(log)
        return dict(events)
    
    def _extract_step_executions(self) -> Dict[str, Dict[str, Any]]:
        """Extract information about step executions."""
        steps = {}
        
        # Find all step execution starts
        for log in self.logs:
            if log.get('event_type') == LogEventType.STEP_EXECUTION_STARTED.name:
                step_id = log.get('context', {}).get('step_id')
                if step_id:
                    steps[step_id] = {
                        'title': log.get('message', '').replace('Executing step: ', ''),
                        'goal': log.get('context', {}).get('step_goal'),
                        'agent_id': log.get('agent_id'),
                        'task_id': log.get('task_id'),
                        'start_time': log.get('timestamp'),
                        'end_time': None,
                        'success': False,
                        'dependencies': log.get('context', {}).get('dependencies', []),
                        'code_executions': 0,
                        'command_executions': 0
                    }
        
        # Find all step execution completions
        for log in self.logs:
            if log.get('event_type') == LogEventType.STEP_EXECUTION_COMPLETED.name:
                step_id = log.get('context', {}).get('step_id')
                if step_id in steps:
                    steps[step_id].update({
                        'end_time': log.get('timestamp'),
                        'success': True,
                        'code_executions': log.get('context', {}).get('code_executions_count', 0),
                        'command_executions': log.get('context', {}).get('command_executions_count', 0),
                        'learning': log.get('context', {}).get('learning', ''),
                        'next_steps_count': log.get('context', {}).get('next_steps_count', 0)
                    })
        
        return steps
    
    def get_execution_summary(self) -> Dict[str, Any]:
        """Get a summary of the agent executions."""
        return {
            'total_logs': len(self.logs),
            'unique_agents': len(self.agents),
            'unique_tasks': len(self.tasks),
            'event_types': {event: len(logs) for event, logs in self.events_by_type.items()},
            'steps_executed': len(self.step_executions),
            'successful_steps': len([s for s in self.step_executions.values() if s.get('success', False)]),
            'code_executions': sum(s.get('code_executions', 0) for s in self.step_executions.values()),
            'command_executions': sum(s.get('command_executions', 0) for s in self.step_executions.values())
        }
    
    def print_summary(self):
        """Print a summary of the analyzed logs."""
        summary = self.get_execution_summary()
        
        print("\n" + "="*80)
        print("MSR LOG ANALYSIS SUMMARY")
        print("="*80)
        
        print(f"\nTotal logs: {summary['total_logs']}")
        print(f"Unique agents: {summary['unique_agents']}")
        print(f"Unique tasks: {summary['unique_tasks']}")
        
        print("\nEvent distribution:")
        for event, count in sorted(summary['event_types'].items(), key=lambda x: x[1], reverse=True):
            print(f"  - {event}: {count}")
        
        print(f"\nSteps executed: {summary['steps_executed']}")
        print(f"Successful steps: {summary['successful_steps']}")
        print(f"Code executions: {summary['code_executions']}")
        print(f"Command executions: {summary['command_executions']}")
        
        if self.tasks:
            print("\nTasks:")
            for task_id, task in self.tasks.items():
                duration = None
                if task.get('start_time') and task.get('end_time'):
                    start = datetime.datetime.fromisoformat(task['start_time'].replace('Z', '+00:00'))
                    end = datetime.datetime.fromisoformat(task['end_time'].replace('Z', '+00:00'))
                    duration = (end - start).total_seconds()
                
                success_rate = task.get('steps_success', 0) / task.get('steps_total', 1) * 100 if task.get('steps_total') else 0
                
                print(f"  - Task: {task.get('description', 'Unknown')[:50]}...")
                print(f"    Success: {task.get('success', False)}")
                print(f"    Steps: {task.get('steps_success', 0)}/{task.get('steps_total', 0)} ({success_rate:.1f}%)")
                if duration:
                    print(f"    Duration: {duration:.2f} seconds")
                print()
    
    def visualize_event_distribution(self, output_file: Optional[str] = None):
        """Visualize the distribution of event types."""
        event_counts = Counter(log.get('event_type') for log in self.logs if log.get('event_type'))
        
        # Create the plot
        plt.figure(figsize=(12, 6))
        
        # Sort events by count
        events = [event for event, _ in sorted(event_counts.items(), key=lambda x: x[1], reverse=True)]
        counts = [event_counts[event] for event in events]
        
        # Create bar chart
        bars = plt.bar(events, counts)
        
        # Add labels and title
        plt.title('Distribution of Event Types')
        plt.xlabel('Event Type')
        plt.ylabel('Count')
        plt.xticks(rotation=45, ha='right')
        plt.tight_layout()
        
        # Add count labels
        for bar in bars:
            height = bar.get_height()
            plt.text(bar.get_x() + bar.get_width()/2., height,
                    f'{height}',
                    ha='center', va='bottom')
        
        # Save or show the plot
        if output_file:
            plt.savefig(output_file)
            print(f"Event distribution visualization saved to {output_file}")
        else:
            plt.show()
    
    def visualize_step_execution_times(self, output_file: Optional[str] = None):
        """Visualize the execution times of different steps."""
        # Extract steps with both start and end times
        steps_with_duration = {}
        for step_id, step in self.step_executions.items():
            if step.get('start_time') and step.get('end_time'):
                start = datetime.datetime.fromisoformat(step['start_time'].replace('Z', '+00:00'))
                end = datetime.datetime.fromisoformat(step['end_time'].replace('Z', '+00:00'))
                duration = (end - start).total_seconds()
                steps_with_duration[step_id] = {
                    'title': step.get('title', step_id),
                    'duration': duration,
                    'success': step.get('success', False)
                }
        
        if not steps_with_duration:
            print("No steps with complete timing information found.")
            return
        
        # Create the plot
        plt.figure(figsize=(12, 6))
        
        # Sort steps by duration
        step_ids = [sid for sid, _ in sorted(steps_with_duration.items(), 
                                          key=lambda x: x[1]['duration'], reverse=True)]
        durations = [steps_with_duration[sid]['duration'] for sid in step_ids]
        titles = [f"{steps_with_duration[sid]['title'][:30]}..." 
                 if len(steps_with_duration[sid]['title']) > 30 
                 else steps_with_duration[sid]['title'] for sid in step_ids]
        colors = ['green' if steps_with_duration[sid]['success'] else 'red' for sid in step_ids]
        
        # Create horizontal bar chart
        bars = plt.barh(titles, durations, color=colors)
        
        # Add labels and title
        plt.title('Step Execution Times')
        plt.xlabel('Duration (seconds)')
        plt.ylabel('Step')
        plt.tight_layout()
        
        # Add duration labels
        for bar in bars:
            width = bar.get_width()
            plt.text(width + 0.5, bar.get_y() + bar.get_height()/2.,
                    f'{width:.2f}s',
                    ha='left', va='center')
        
        # Add legend
        plt.legend([plt.Rectangle((0,0),1,1,color='green'), 
                  plt.Rectangle((0,0),1,1,color='red')],
                  ['Success', 'Failure'])
        
        # Save or show the plot
        if output_file:
            plt.savefig(output_file)
            print(f"Step execution time visualization saved to {output_file}")
        else:
            plt.show()


def main():
    """Parse command line arguments and run the log analyzer."""
    parser = argparse.ArgumentParser(description="Analyze and visualize MSR agent logs.")
    
    # Log file input
    parser.add_argument("--log-file", required=True, help="Path to the log file to analyze")
    
    # Visualization options
    parser.add_argument("--visualize-events", action="store_true", help="Visualize event distribution")
    parser.add_argument("--visualize-timing", action="store_true", help="Visualize step execution times")
    parser.add_argument("--output-dir", help="Directory to save visualizations")
    
    args = parser.parse_args()
    
    # Create output directory if specified
    if args.output_dir:
        os.makedirs(args.output_dir, exist_ok=True)
    
    # Create and run the analyzer
    analyzer = LogAnalyzer(args.log_file)
    analyzer.print_summary()
    
    # Generate visualizations if requested
    if args.visualize_events:
        output_file = os.path.join(args.output_dir, "event_distribution.png") if args.output_dir else None
        analyzer.visualize_event_distribution(output_file)
    
    if args.visualize_timing:
        output_file = os.path.join(args.output_dir, "step_execution_times.png") if args.output_dir else None
        analyzer.visualize_step_execution_times(output_file)


if __name__ == "__main__":
    main() 